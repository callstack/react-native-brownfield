# Swift Usage

Use stores in iOS apps with SwiftUI or UIKit.

:::info Android
Android support is coming soon.
:::

## Setup

Initialize the store in your app's entry point:

```swift
import Brownie
import ReactBrownfield
import SwiftUI

let initialState = BrownfieldStore(
  counter: 0,
  user: User(name: "")
)

@main
struct MyApp: App {
  init() {
    // Start React Native
    ReactNativeBrownfield.shared.startReactNative {
      print("React Native loaded")
    }

    // Initialize store with initial state
    _ = Store(initialState, key: BrownfieldStore.storeName)
  }

  var body: some Scene {
    WindowGroup {
      ContentView()
    }
  }
}
```

## SwiftUI

### @UseStore Property Wrapper

The `@UseStore` property wrapper provides reactive access to the store:

```swift
import Brownie
import SwiftUI

struct ContentView: View {
  @UseStore<BrownfieldStore> var store

  var body: some View {
    VStack {
      Text("Count: \(Int(store.state.counter))")

      Button("Increment") {
        store.set { $0.counter += 1 }
      }
    }
  }
}
```

### Updating State

Use the `set` method with a closure to mutate state:

```swift
// Update single property
store.set { $0.counter += 1 }

// Update nested property
store.set { $0.user.name = "John" }

// Update multiple properties
store.set {
  $0.counter = 0
  $0.user.name = "Reset"
}
```

### TextField Binding

For two-way binding with TextField, create a `Binding`:

```swift
struct ContentView: View {
  @UseStore<BrownfieldStore> var store

  var body: some View {
    TextField("Name", text: Binding(
      get: { store.state.user.name },
      set: { store.set { $0.user.name = $0 } }
    ))
    .textFieldStyle(.roundedBorder)
  }
}
```

### Reading State

Access state via the `state` property or keypaths:

```swift
// Via state property
let counter = store.state.counter
let name = store.state.user.name

// Via keypath subscript
let counter = store[\.counter]

// Via get method
let counter = store.get(\.counter)
```

## UIKit

For UIKit, use `StoreManager` to retrieve stores and `subscribe` for updates.

### Full UIKit Example

```swift
import UIKit
import Brownie

class CounterViewController: UIViewController {
  private var store: Store<BrownfieldStore>?
  private var cancelSubscription: (() -> Void)?

  private let counterLabel: UILabel = {
    let label = UILabel()
    label.font = .systemFont(ofSize: 24, weight: .bold)
    label.translatesAutoresizingMaskIntoConstraints = false
    return label
  }()

  private let incrementButton: UIButton = {
    var config = UIButton.Configuration.borderedProminent()
    config.title = "Increment"
    let button = UIButton(configuration: config)
    button.translatesAutoresizingMaskIntoConstraints = false
    return button
  }()

  override func viewDidLoad() {
    super.viewDidLoad()
    setupUI()
    setupStore()
  }

  private func setupUI() {
    view.backgroundColor = .systemBackground

    let stack = UIStackView(arrangedSubviews: [counterLabel, incrementButton])
    stack.axis = .vertical
    stack.spacing = 16
    stack.translatesAutoresizingMaskIntoConstraints = false

    view.addSubview(stack)
    NSLayoutConstraint.activate([
      stack.centerXAnchor.constraint(equalTo: view.centerXAnchor),
      stack.centerYAnchor.constraint(equalTo: view.centerYAnchor)
    ])

    incrementButton.addTarget(self, action: #selector(incrementTapped), for: .touchUpInside)
  }

  private func setupStore() {
    // Retrieve store from manager
    store = StoreManager.get(key: BrownfieldStore.storeName, as: BrownfieldStore.self)

    guard let store else {
      counterLabel.text = "Store not found"
      return
    }

    // Initial UI update
    updateUI(with: store.state)

    // Subscribe to changes
    cancelSubscription = store.subscribe { [weak self] state in
      self?.updateUI(with: state)
    }
  }

  private func updateUI(with state: BrownfieldStore) {
    counterLabel.text = "Count: \(Int(state.counter))"
  }

  @objc private func incrementTapped() {
    store?.set { $0.counter += 1 }
  }

  deinit {
    cancelSubscription?()
  }
}
```

### Subscribe to Specific Property

Subscribe to a specific property to only receive updates when it changes:

```swift
// Subscribe to counter only
cancelSubscription = store.subscribe(\.counter) { [weak self] counter in
  self?.counterLabel.text = "Count: \(Int(counter))"
}
```

## API Reference

### Store&lt;State&gt;

| Method                   | Description                             |
| ------------------------ | --------------------------------------- |
| `init(_:key:)`           | Create store with initial state and key |
| `state`                  | Current state (read-only)               |
| `set(_:)`                | Update state with closure               |
| `set(_:to:)`             | Update property via keypath             |
| `get(_:)`                | Get property via keypath                |
| `subscribe(onChange:)`   | Subscribe to all state changes          |
| `subscribe(_:onChange:)` | Subscribe to specific property changes  |

### StoreManager

| Method                      | Description                 |
| --------------------------- | --------------------------- |
| `StoreManager.get(key:as:)` | Retrieve typed store by key |
| `shared.snapshot(key:)`     | Get raw snapshot dictionary |
| `shared.removeStore(key:)`  | Remove and cleanup store    |

### @UseStore

Property wrapper for SwiftUI that auto-discovers store by type's `storeName`.

```swift
@UseStore<BrownfieldStore> var store
```

Requires generated type to conform to `BrownieStoreProtocol`.
