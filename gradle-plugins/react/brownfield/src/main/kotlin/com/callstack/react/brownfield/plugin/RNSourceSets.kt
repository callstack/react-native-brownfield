package com.callstack.react.brownfield.plugin

import com.android.build.gradle.LibraryExtension
import com.callstack.react.brownfield.exceptions.NameSpaceNotFound
import com.callstack.react.brownfield.shared.Constants
import com.callstack.react.brownfield.shared.Logging
import com.callstack.react.brownfield.utils.Extension
import com.callstack.react.brownfield.utils.Utils
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.file.Directory
import org.gradle.api.tasks.Copy
import java.io.File

object RNSourceSets {
    private lateinit var project: Project
    private lateinit var extension: Extension
    private lateinit var androidExtension: LibraryExtension
    private lateinit var appProject: Project
    private lateinit var appBuildDir: Directory
    private lateinit var moduleBuildDir: Directory

    fun configure(
        project: Project,
        extension: Extension,
    ) {
        /**
         * Do not configure sourceSets for our example library.
         * The reason is that we expect some RN specific tasks to
         * be present on the consuming library, which is not the case
         * with our example library.
         */
        if (Utils.isExampleLibrary(project.name)) {
            return
        }
        this.project = project
        this.extension = extension

        androidExtension = RNSourceSets.project.extensions.getByName("android") as LibraryExtension
        appProject = RNSourceSets.project.rootProject.project(RNSourceSets.extension.appProjectName)
        appBuildDir = appProject.layout.buildDirectory.get()
        moduleBuildDir = RNSourceSets.project.layout.buildDirectory.get()

        configureSourceSets()
        configureTasks()
    }

    private fun genAssetsPath(bundlePathSegment: String): String {
        return "${appBuildDir}/generated/assets/$bundlePathSegment"
    }

    private fun configureSourceSets() {
        androidExtension.sourceSets.getByName("main") {
            // path on RN >= 0.82.x
            val rn082UpAssetsDir =
                File(genAssetsPath(Constants.RN_0_82_UP_BUNDLE_PATH_SEGMENT))
            val rn082UpAssetsDirExists = rn082UpAssetsDir.exists()
            // path on RN <= 0.81.x
            val rn081DownAssetsDir =
                File(genAssetsPath(Constants.RN_0_81_DOWN_BUNDLE_PATH_SEGMENT))
            val rn081DownAssetsDirExists = rn081DownAssetsDir.exists()

            if (rn081DownAssetsDirExists && rn082UpAssetsDirExists) {
                Logging.warn(
                    "Two RN autogenerated asset paths exist: ${rn082UpAssetsDir.path} (RN >= 0.82) and ${rn081DownAssetsDir.path}" +
                            "(Rock project or RN < 0.82). The newer path will be used (${rn082UpAssetsDir.path})."
                )
                Logging.warn(
                    "It is likely that you have upgraded RN versions and should clean your app's " +
                            "build directory and rebuild just once in order for this warning to disappear."
                )
            }

            val bundlePathSegment =
                if (rn082UpAssetsDirExists) Constants.RN_0_82_UP_BUNDLE_PATH_SEGMENT else Constants.RN_0_81_DOWN_BUNDLE_PATH_SEGMENT
            it.assets.srcDirs(genAssetsPath(bundlePathSegment))
            it.res.srcDirs("$appBuildDir/generated/res/react/$bundlePathSegment")
            it.java.srcDirs("$moduleBuildDir/generated/autolinking/src/main/java")
        }

        androidExtension.sourceSets.getByName("release") {
            it.jniLibs.srcDirs("libsRelease")
        }

        androidExtension.sourceSets.getByName("debug") {
            it.jniLibs.srcDirs("libsDebug")
        }
    }

    private fun getLibraryNameSpace(): String {
        val nameSpace = androidExtension.namespace
        return nameSpace
            ?: throw NameSpaceNotFound("namespace must be defined in your android library build.gradle")
    }

    private fun patchRNEntryPoint(
        task: Task,
        path: String,
    ) {
        val rnEntryPointTaskName = "generateReactNativeEntryPoint"

        /**
         * If `generateReactNativeEntryPoint` task does not exist, we early return. It means
         * the consumer library is running on RN version < 0.80
         */
        val rnEntryPointTask = appProject.tasks.findByName(rnEntryPointTaskName) ?: return

        task.dependsOn(rnEntryPointTask)
        val sourceFile = File(
            moduleBuildDir.toString(),
            "$path/com/facebook/react/ReactNativeApplicationEntryPoint.java"
        )
        task.doLast {
            if (sourceFile.exists()) {
                var content = sourceFile.readText()
                val nameSpace = getLibraryNameSpace()

                /**
                 * We use look-ahead regex to replace any occurrences with Build.Config referenced via the old(app) package
                 *
                 * \b[\w.]+ → matches the old package
                 * (?=\.BuildConfig) → only if it’s immediately followed by that suffix
                 */
                val regex = Regex("""\b[\w.]+(?=\.BuildConfig)""")
                content = content.replace(regex, nameSpace)
                sourceFile.writeText(content)
            }
        }
    }

    private fun configureTasks() {
        val appProjectName = appProject.name

        project.tasks.register("copyAutolinkingSources", Copy::class.java) {
            val path = "generated/autolinking/src/main/java"
            it.dependsOn(":$appProjectName:generateAutolinkingPackageList")
            it.from("$appBuildDir/$path")
            it.into("$moduleBuildDir/$path")

            patchRNEntryPoint(it, path)
        }

        project.tasks.named("preBuild").configure {
            /**
             * Ensure auto-generated sources are available before compilation.
             *
             * This hooks into the global `preBuild` task, so the dependency runs
             * regardless of build variant. Use this only when the generated sources
             * are identical for all variants (debug/release).
             *
             * If variant-specific
             * files are needed, prefer `preDebugBuild` / `preReleaseBuild` under
             * `VariantProcessor.processVariant`
             */
            it.dependsOn("copyAutolinkingSources")
        }
    }
}
